### 347. Top K Frequent Elements

[Description](https://leetcode.com/problems/top-k-frequent-elements/description/)[Hints](https://leetcode.com/problems/top-k-frequent-elements/hints/)[Submissions](https://leetcode.com/problems/top-k-frequent-elements/submissions/)[Discuss](https://leetcode.com/problems/top-k-frequent-elements/discuss/)[Solution](https://leetcode.com/problems/top-k-frequent-elements/solution/)

[Pick One](https://leetcode.com/problems/random-one-question/)

------

Given a non-empty array of integers, return the **k** most frequent elements.

For example,
Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.

**Note:** 

- You may assume *k* is always valid, 1 ≤ *k* ≤ number of unique elements.
- Your algorithm's time complexity **must be** better than O(*n* log *n*), where *n* is the array's size.



##### 思路一

扫描一遍统计频率O(n), 根据频率排序O(nlogn)并查找前k个出现频率最高O(k)的元素。　总共O(nlogn).

瓶颈在排序，能不能不排序？



##### 思路二　使用优先队列

维护一个长度为k的优先队列




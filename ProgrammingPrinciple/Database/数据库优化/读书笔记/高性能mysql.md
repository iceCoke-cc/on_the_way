

InnoDB采用两阶段锁协议，只有在commit或rollback时，释放，同一时刻释放。

InnoDB显示锁定：select .. lock in shared mode / for update

mysql在服务层实现：lock/unlock tables，不能代替事务。

多版本并发控制MVCC:乐观、悲观。

InnoDB的MVCC通过在每一行增加行的创建版本号和过期版本号来实现。每开始一个新的事务，系统版本号都会自动递增，事务开始时的系统版本号会作为事务的版本号，用来和查询的每行记录的版本号进行比较。

- insert:为插入的行保存当前系统版本号作为行版本号
- delete:为删除的每一行保存当前系统版本号为行删除标识
- update:保存当前系统版本号为行版本号，保存当前系统版本号到原来的行作为行删除标识。


- slelct:
  - 行记录在事务开始前已存在，或者被事务自身修改。即行记录的版本号<=事务系统版本号
  - 行记录在事务开始前未被删除。即行的删除版本要么未定义，要么大于事务版本号

Innodb通过间隙锁策略防止幻读。

**选择优化的数据类型**：

- 使用能正确存储数据的最小数据类型
- 使用简单类型，整形比字符操作代价低，因为字符集和校对规则比整形更复杂。使用內建类型存储时间而不是字符串，用整形存IP地址
- 避免使用NULL,因为null的列使得索引、索引统计和值比较都更复杂，甚至会存储更多的空间。
- TIMESTAMP会根据时区变化，范围小，需要的空间页小。比DATETIME。

整数类型：(unsigned) tinyint8, smallint16, mediumint24, int32, bigint64.$-2^{N-1} ... 2^{N-1}-1$，整数计算一般使用64位的BIGINT。聚合函数除外。 INT(1)与INT(20)是一样的。

实数类型：float4, double8, decimal(比bigint还大).double为内部浮点计算类型。其实可以将decimal转为bitint。3.14 314

字符串：>5.0 保留末尾空格

- varchar:<256,1;否则需要2个字节来存储长度。节约空间，但性能下降。如果将原来行记录的字符串更新为更长的字符串，在页内没有更多的存储空间，则需要进行单独处理。innodb:分裂页使行可以放进页内。适合场景：
  - 字符串的最大长度比平均长度长很多
  - 列的更新少
  - 使用了UTF-8的复杂字符集
- char:定长。会丢弃末尾空格？
- 只分配需要的空间更好。

binary varbinary:二进制，数据比较时，只比较二进制数，所以性能高。

blob:二进制存储字符换，没有字符集和排序规则

text:字符方式存储，有字符集和排序规则

因为字符太大，InnoDB会在行内存储1~4个字节的指针，指向外部存储区域的实际值。在排序时，只对前面的部分字符进行排序，或者使用 order by sustring(column, length)

枚举：将常用的字符串用枚举来表示，内部转为整形数字。

datetime:与时区无关，存为yyyymmddhhmmss整数

timestamp:from_unixtime(), unix_timestamp()默认not null

bit:底层作为字符串处理，而不是数字。慎用。true/false可用char(0)代替，null/长度为0的字符串。

set:内部以一系列打包的位的集合来表示。缺点：改变列的定义的代价较高。可以在整数列上按位操作来代替。

mysql在内部使用整存储ENUM和SET，在比较的时候转为字符串。

确保在关联表时使用相同的数据类型。








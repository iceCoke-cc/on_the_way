## 基础

[TOC]

### １．gcc编译

分步编译：(-o为指定生成文件名)

1. 预处理： gcc -E hello.c -o hello.i  　宏定义展开、头文件展开、条件编译、删除注释。不检查语法。
2. 编　译： gcc -S hello.i -o hello.s　检查语法，将预处理后的文件编译生成汇编文件
3. 汇　编： gcc -c hello.s -o hello.o　将汇编文件生成目标文件(二进制文件)，但不可执行(例如图像)。
4. 链　接： gcc     hello.o -o hello_elf　将需要的库链接到最终的可执行文件中去。

查看软件需要的库：　ldd命令、Depends.exe



### ２．关键字

#### extren

extern int a; 声明变量a，但是没有申请分配空间。

#### define

\#开头的为预处理语句，无需分好结束

在预处理阶段，只要出现MAX出现的地方，都由100来替代。

为常量，不允许修改。

```c
#define MAX 100　//
```

#### const

修饰变量为只读，不允许修改。

#### goto

只能跳转到统一作用域

#### break

只跳出最内层循环



### 3. 数组

不初始化的局部数组为随机数。

数组名是首元素地址。

内层中只有一维。

```c
int a[10];
int a[3] = {1,2,3}; //其余元素补０
int a[10] = {0}; //全部初始化为０
int n = sizeof(a)/sizeof(a[0]); //数组大小
int a[2][2] = {0}
```

 C原因中没有字符串类型，用字符数组模拟，以'\0'来结尾。'\0'与0等价。

\0后面最好别跟数字，因为有可能跟后面的数字组成一个转移字符。'\012'就时'\n'.

```c
char a[] = {'a','b','\0'}; //字符串
char a[] = {'a','b',0};　//字符串
char a[] = {'a','c'};　//字符数组,长度为2
char a[] = "abc";//自动在末尾添加'\0'，长度为４
printf("%s\n", a);//以字符串输出时，找到'\0'就提前或延后结束。
```

sizeof(a)测数据类型大小，不会因为中间的'\0'而影响，跟'\0'无关。

unsigned int strlen(const char *s); 计算第一个结束符'\0'之前的字符长度; \<string.h>



### 4.字符串处理函数

scanf("%s", arr); //将输入放入缓冲区，并以**空格**分割。linux下不做越界检查，**不安全**。

char *gets(char *s); //从标准输入读入字符，并保存到s空间，直到出现**换行符号或者文件末尾**。失败返回NULL。也不做越界检查，**不安全**。

char *fgets(char *s, int size, FILE *stream); //从stream中(stdin为标准输入)读入字符，保存到ｓ空间，直到出现换行、文件尾部或已经读了size-1个字符为止，如果新行可读，则会存到buffer中。最后自动加上'\0'作为字符串结束。fgets(buf, sizeof(buf), stdin).

**安全**。

输出：

int puts(const char *s); 标准设备输出ｓ字符串，自动　在后面添加换行符。

int fputs(const char *str, FILE * stream); 将str的字符串写到stream(stdout)中，字符串结束符'\0'不写入文件。

strcpy(des, src); 从src拷贝，遇到'\0'结束

strncpy(des, src, 8);拷贝指定的８个，若遇到'\0'提前结束　memcpy()可以拷贝'\0'

int strcmp(const char *s1, const char *s2);

int strncmp(const char *s1, const char *s2, int n);//指定比较前n个字符

strcat(dst,src); 将src追加到dst

sprintf(dst, "a = %d\n", a); 将格式化的字符串输出到dst数组

sscanf(src, "%d, %d", &a, &b); 将src中的数字以src的格式提取出来给a,b。　提取字符串，默认以空格分割，其它不行。

char *strchr(const char *s, int c);返回c在ｓ中的第一次的地址

char *strstr(const char *s, const char *newstr)；返回newstr第一次出现的地址

char *strtok(char *str, const char *delim);将切割字符换成结束符。会破坏原来的字符换。第二次调用时，第一个参数需要写NULL，p = strtok(NULL, ','); 用循环写比较合适。

int atoi(const char *nptr);跳过前面的空格字符，转换数字字符，直到遇到非数字字符或者结尾。

atof, atol

将数字转为字符串： sprintf(buf, "%d", 123);

函数中的exit(1);会结束整个进程。



### 头文件

调用函数时，只会往前找定义和声明，没有的化，ｃ编译器会警告、c++会出错。

声明告诉编译器，这个函数是有定义的，只是放在了别的地方。

在用之前必须有定义，如果之前没有定义，必须在调用前声明。

一个函数只能定义一次，但可以声明多次。

声明的形参名可以不一样，甚至可以不写形参变量名。

函数定义放在a.c中，声明放在a.h中，在使用时，只需要include "a.h"即可，告诉编译器在别的地方有函数定义。

为解决include多次同一个.h文件，可以采用两种方式：

```c
#pragma once

#ifndef _A_H
#define _A_H
extern int my_strlen(char buf[]);
#endid;          
```



### 指针

%p以１６进制打印指针。

＆a: 对变量a取地址

*a：对变量a解地址，取其地址上的内容。

**操作野指针变量本身p=0x123没有问题，但是操作野指针指向的内存*p=100就会导致内存段错误。**

```c
*p == *(p+０．) == p[0]　
```

万能指针：void* 可以指向任何类型(类型匹配)，使用时要转化为它本身的指针类型，要确定解析多少字节地址。

```
void* p = &a;
*( (int *)p ) = 100;
```

指针步长：为指针指向的数据类型大小。void*不能确定步长。

```c
const int* p; //指针所指向的内存只读
int const* p;　//指针所指向的内存只读
int * const p; //指针p只读。
```

指针数组：指针的数组，它是数组，每个元素都是指针　int* p[3];

数组指针：数组的指针，它是指针，指向数组的指针

swap(a,b) 不管变量是什么类型，只要是变量本身传递，就是值传递。

swap(&a, &b) 地址传递，变量的地址。

形参中的数组： fun(int a[]),  fun(int* a), fun(int a[100])都当做 int* a处理。所以sizeof(a)的大小只是指针大小。

但是：fun(int b\[][]) 不等价于 fun(int **p)　即二位数组不是二级指针。

fun(char * p[10])，fun(char * p[])，　fun(char * *p)即指针数组。

```c
int main(int argc, char *argv[]){
    int i = 0;
    for(i = 0; i < argc; i++)
        printf("%s ", argv[i]); //
    return 0;
}
```



int* fun(); 返回值为指针类型

在linux 64下不允许返回局部变量的地址。

printf("%s", str); 打印整个字符串

printf("%s", *str); 打印第一个字符	*(str+1)



全局变量：

```c
int a; //普通全局变量，在任何地方都可以使用，整个程序结束后才释放。
int main(){
    
}
```



字符串常量放在data区，**文字常量区**。每个字符代表字符串的首元素地址。"abc"，"abc"+1代表"b"的地址。

企图通过指针来修改字符串常量，则会出现段错误：char *p = "hello"; strcpy(p, "abc");

字符串常量区与程序声明周期一样。

字符数组不用于文字常量：char buf[]="abc"; char *p="abc";　两者不同。后者在字符常量区，前者则可以改。



























### 额外功能

#### 产生随机数

```c
#include <time.h>
#include <stdlib.h>
int main(){
    srand( (unsigned int)time(NULL) );//以时间作为种子
    srand(100);
    int num = rand();
}
```
